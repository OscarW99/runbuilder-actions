name: iOS Firebase Distribution

on:
  workflow_dispatch:  # Manual trigger only - YOU control when to build
    inputs:
      release_notes:
        description: 'Release notes for this build'
        required: false
        default: 'Latest updates and improvements'
  # Optional: Add schedule for automatic builds
  # schedule:
  #   - cron: '0 12 */6 * *'  # Auto-rebuild every 6 days to prevent expiration

jobs:
  build-ios:
    name: Build & Distribute iOS App
    runs-on: macos-14  # Use specific macOS version instead of latest
    
    steps:
    - name: Checkout private repository
      uses: actions/checkout@v4
      with:
        repository: OscarW99/runbuilder
        token: ${{ secrets.PRIVATE_REPO_PAT }}  # PAT with repo access to private repo
        path: private-repo
        
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        channel: 'stable'
        
    - name: Install dependencies
      run: |
        cd private-repo/runbuilder
        flutter pub get
        
    - name: Auto-increment Version and Build Number
      run: |
        cd private-repo/runbuilder
        
        # Get current version from pubspec.yaml
        CURRENT_VERSION=$(grep "^version:" pubspec.yaml | cut -d' ' -f2)
        echo "Current version: $CURRENT_VERSION"
        
        # Extract version number and build number
        VERSION_NUMBER=$(echo $CURRENT_VERSION | cut -d'+' -f1)
        BUILD_NUMBER=$(echo $CURRENT_VERSION | cut -d'+' -f2)
        
        echo "Current version number: $VERSION_NUMBER"
        echo "Current build number: $BUILD_NUMBER"
        
        # Extract major, minor, patch from version number (e.g., 1.0.1 -> 1, 0, 1)
        MAJOR=$(echo $VERSION_NUMBER | cut -d'.' -f1)
        MINOR=$(echo $VERSION_NUMBER | cut -d'.' -f2)
        PATCH=$(echo $VERSION_NUMBER | cut -d'.' -f3)
        
        # Auto-increment patch version every deployment
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION_NUMBER="${MAJOR}.${MINOR}.${NEW_PATCH}"
        
        # Reset build number to 1 for new version, or increment if version unchanged
        NEW_BUILD_NUMBER=1
        NEW_VERSION="${NEW_VERSION_NUMBER}+${NEW_BUILD_NUMBER}"
        
        echo "New version: $NEW_VERSION (patch incremented from $PATCH to $NEW_PATCH)"
        
        # Update pubspec.yaml
        sed -i.bak "s/^version: .*/version: $NEW_VERSION/" pubspec.yaml
        
        # Verify the change
        echo "Updated pubspec.yaml:"
        grep "^version:" pubspec.yaml
        
    - name: Clean and Setup iOS Pods
      run: |
        cd private-repo/runbuilder/ios
        # Clean existing pods installation
        rm -rf Pods
        rm -rf Podfile.lock
        # Install pods with repo update - this will apply our Podfile post_install hook
        pod install --repo-update
        
        # Verify that our post_install hook worked - check pod signing settings
        echo "=== Verifying Pod Code Signing Settings ==="
        grep -A 5 -B 5 "CODE_SIGN_STYLE" Pods/Pods.xcodeproj/project.pbxproj | head -20 || echo "No CODE_SIGN_STYLE found (which is expected for automatic signing)"
        
    - name: Setup Environment File
      run: |
        cd private-repo/runbuilder
        echo "GOOGLE_MAPS_API_KEY=${{ secrets.GOOGLE_MAPS_API_KEY }}" > .env
        echo "STRAVA_CLIENT_ID=${{ secrets.STRAVA_CLIENT_ID }}" >> .env
        echo "STRAVA_CLIENT_SECRET=${{ secrets.STRAVA_CLIENT_SECRET }}" >> .env
        echo "Environment file created with API keys"
        
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Build iOS App
      run: |
        cd private-repo/runbuilder
        
        # Extract version info from pubspec.yaml
        VERSION_LINE=$(grep "^version:" pubspec.yaml)
        VERSION_NUMBER=$(echo $VERSION_LINE | cut -d' ' -f2 | cut -d'+' -f1)
        BUILD_NUMBER=$(echo $VERSION_LINE | cut -d'+' -f2)
        
        echo "Building with version: $VERSION_NUMBER, build: $BUILD_NUMBER"
        
        # Build iOS with proper versioning
        flutter build ios --release --no-codesign \
          --build-name="$VERSION_NUMBER" \
          --build-number="$BUILD_NUMBER"
        
    - name: Install Apple Certificate and Provisioning Profile
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create variables
        CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
        PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

        # Import certificate and provisioning profile from secrets
        echo "$BUILD_CERTIFICATE_BASE64" | base64 --decode > $CERTIFICATE_PATH
        echo "$BUILD_PROVISION_PROFILE_BASE64" | base64 --decode > $PP_PATH

        # DEBUG: Check if P12 file was decoded correctly
        echo "=== P12 File Debug ==="
        file $CERTIFICATE_PATH
        ls -la $CERTIFICATE_PATH
        echo "Trying to verify P12 file with openssl..."
        P12_PASSWORD_CLEAN=$(echo "$P12_PASSWORD" | tr -d '\n\r' | tr -d ' ')
        openssl pkcs12 -info -in $CERTIFICATE_PATH -noout -passin pass:"$P12_PASSWORD_CLEAN" || echo "P12 verification failed"
        
        # FIX: Convert P12 to macOS-compatible format using OpenSSL
        echo "=== Converting P12 to macOS-compatible format ==="
        openssl pkcs12 -in $CERTIFICATE_PATH -out /tmp/temp_cert.pem -clcerts -nokeys -passin pass:"$P12_PASSWORD_CLEAN"
        openssl pkcs12 -in $CERTIFICATE_PATH -out /tmp/temp_key.pem -nocerts -nodes -passin pass:"$P12_PASSWORD_CLEAN"
        openssl pkcs12 -export -out /tmp/fixed_certificate.p12 -in /tmp/temp_cert.pem -inkey /tmp/temp_key.pem -passin pass:"$P12_PASSWORD_CLEAN" -passout pass:"$P12_PASSWORD_CLEAN" -name "iOS Distribution"
        
        # Use the fixed P12 file
        CERTIFICATE_PATH=/tmp/fixed_certificate.p12

        # Create temporary keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

        # Import certificate to keychain (with proper password cleaning)
        P12_PASSWORD_CLEAN=$(echo "$P12_PASSWORD" | tr -d '\n\r' | tr -d ' ')
        security import $CERTIFICATE_PATH -P "$P12_PASSWORD_CLEAN" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH

        # Apply provisioning profile
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles

        # Extract provisioning profile UUID for later use
        PROFILE_UUID=$(security cms -D -i $PP_PATH | plutil -extract UUID xml1 -o - - | sed -n 's/.*<string>\(.*\)<\/string>.*/\1/p')
        echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
        echo "Provisioning Profile UUID: $PROFILE_UUID"

    - name: Debug Code Signing Setup
      run: |
        echo "=== Available Code Signing Identities ==="
        security find-identity -v -p codesigning
        echo ""
        echo "=== Installed Provisioning Profiles ==="
        ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
        echo ""
        echo "=== Profile UUID ==="
        echo "PROFILE_UUID: $PROFILE_UUID"
        echo ""
        echo "=== Certificate Details ==="
        security find-identity -v -p codesigning | grep "5GNC2JSW59" || echo "No certificate found for team 5GNC2JSW59"
        echo ""
        echo "=== Provisioning Profile Details ==="
        security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | head -50
        echo ""
        echo "=== Check Certificate in NEW Profile ==="
        security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | grep -A 20 -B 5 "DeveloperCertificates"
        echo ""
        echo "=== Current Certificate SHA1 ==="
        security find-identity -v -p codesigning | grep "5GNC2JSW59"

    - name: Build and Sign IPA with Fresh Certificates
      run: |
        cd private-repo/runbuilder
        
        # Find the correct signing identity
        SIGNING_IDENTITY=$(security find-identity -v -p codesigning | grep "5GNC2JSW59" | head -1 | cut -d '"' -f 2)
        echo "Using signing identity: $SIGNING_IDENTITY"
        
        # Reinstall pods to apply Podfile signing changes
        echo "=== Reinstalling Pods to Apply Signing Changes ==="
        cd ios
        pod install
        cd ..
        
        # Build without global signing settings - let individual targets handle their own signing
        echo "=== Building with Target-Specific Signing ==="
        xcodebuild -workspace ios/Runner.xcworkspace \
                   -scheme Runner \
                   -configuration Release \
                   -destination generic/platform=iOS \
                   -archivePath build/Runner.xcarchive \
                   clean archive
        
        # Create export options plist for ad-hoc distribution
        cat > build/ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>ad-hoc</string>
            <key>teamID</key>
            <string>5GNC2JSW59</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>provisioningProfiles</key>
            <dict>
                <key>com.oscarw99.runbuilder</key>
                <string>$PROFILE_UUID</string>
            </dict>
        </dict>
        </plist>
        EOF
                   
        # Export IPA
        xcodebuild -exportArchive \
                   -archivePath build/Runner.xcarchive \
                   -exportPath build/ \
                   -exportOptionsPlist build/ExportOptions.plist
        
        # Debug: Check what files were created
        echo "=== Files in build directory after export ==="
        ls -la build/
        echo "=== Looking for IPA files ==="
        find build/ -name "*.ipa" -type f
        
        # Find the actual IPA file and get the absolute path
        IPA_FILE=$(find build/ -name "*.ipa" -type f | head -1)
        if [ -z "$IPA_FILE" ]; then
            echo "ERROR: No IPA file found!"
            exit 1
        fi
        
        # Convert to absolute path to avoid path issues
        IPA_ABSOLUTE_PATH=$(realpath "$IPA_FILE")
        echo "Found IPA file: $IPA_FILE"
        echo "Absolute IPA path: $IPA_ABSOLUTE_PATH"
        echo "IPA_PATH=$IPA_ABSOLUTE_PATH" >> $GITHUB_ENV
                   
    - name: Upload IPA as Artifact
      uses: actions/upload-artifact@v4
      with:
        name: RunBuilder-iOS-${{ github.run_number }}
        path: ${{ env.IPA_PATH }}
        retention-days: 30
        
    - name: Install Firebase CLI and Google Cloud SDK
      run: |
        # Install Firebase CLI
        npm install -g firebase-tools
        echo "Firebase CLI installed"
        firebase --version
        
        # Use the official Google Cloud SDK setup action instead of manual install
        echo "Setting up Google Cloud authentication..."
        # We'll use the service account directly with Firebase CLI
        echo "Google Cloud SDK setup will be handled via service account JSON"
        
    - name: Authenticate with Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
        project_id: ${{ secrets.FIREBASE_PROJECT_ID }}
        
    - name: Upload to Firebase App Distribution  
      env:
        FIREBASE_APP_ID: ${{ secrets.FIREBASE_APP_ID }}
        FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
        FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
      run: |
        cd private-repo/runbuilder
        
        echo "[DEBUG] =================================="
        echo "[DEBUG] SECURE SECRET VERIFICATION"
        echo "[DEBUG] =================================="
        
        # Hash-based verification to ensure secrets are present without exposing them
        echo " Verifying secret integrity using hash verification..."
        
        # Verify FIREBASE_SERVICE_ACCOUNT (use shasum on macOS)
        SA_HASH=$(echo -n "$FIREBASE_SERVICE_ACCOUNT" | shasum -a 256 | cut -d' ' -f1)
        echo "FIREBASE_SERVICE_ACCOUNT hash: ${SA_HASH:0:16}...${SA_HASH:48:16}"
        if [ ${#SA_HASH} -eq 64 ]; then
            echo "[SUCCESS] FIREBASE_SERVICE_ACCOUNT: Present and valid length"
        else
            echo "[ERROR] FIREBASE_SERVICE_ACCOUNT: Missing or invalid"
        fi
        
        # Verify FIREBASE_PROJECT_ID
        PROJECT_HASH=$(echo -n "$FIREBASE_PROJECT_ID" | shasum -a 256 | cut -d' ' -f1)
        echo "FIREBASE_PROJECT_ID hash: ${PROJECT_HASH:0:16}...${PROJECT_HASH:48:16}"
        if [ ${#FIREBASE_PROJECT_ID} -gt 5 ]; then
            echo "[SUCCESS] FIREBASE_PROJECT_ID: Present (length: ${#FIREBASE_PROJECT_ID})"
        else
            echo "[ERROR] FIREBASE_PROJECT_ID: Missing or too short"
        fi
        
        # Verify FIREBASE_APP_ID
        APP_HASH=$(echo -n "$FIREBASE_APP_ID" | shasum -a 256 | cut -d' ' -f1)
        echo "FIREBASE_APP_ID hash: ${APP_HASH:0:16}...${APP_HASH:48:16}"
        if [ ${#FIREBASE_APP_ID} -gt 10 ]; then
            echo "[SUCCESS] FIREBASE_APP_ID: Present (length: ${#FIREBASE_APP_ID})"
        else
            echo "[ERROR] FIREBASE_APP_ID: Missing or too short"
        fi
        
        echo " =================================="
        echo " ULTRA-VERBOSE FIREBASE DEBUGGING"
        echo " =================================="
        
        echo " Step 1: Environment verification"
        echo "Current working directory: $(pwd)"
        echo "FIREBASE_PROJECT_ID length: ${#FIREBASE_PROJECT_ID}"
        echo "FIREBASE_APP_ID length: ${#FIREBASE_APP_ID}"
        echo "FIREBASE_SERVICE_ACCOUNT length: ${#FIREBASE_SERVICE_ACCOUNT}"
        
        # Find the actual IPA file dynamically
        echo " Searching for IPA file..."
        IPA_FILE=$(find . -name "*.ipa" -type f | head -1)
        if [ -n "$IPA_FILE" ]; then
            IPA_PATH="$IPA_FILE"
            echo "[SUCCESS] Found IPA file: '$IPA_PATH'"
        else
            # Fallback to expected path
            IPA_PATH="build/ios/ipa/Runner.ipa"
            echo "[WARNING] No IPA found, using expected path: '$IPA_PATH'"
        fi
        
        echo " Step 2: Directory structure"
        echo "PWD: $(pwd)"
        echo "USER: $(whoami)"
        echo "PATH: $PATH"
        echo "Files in current directory:"
        ls -la
        
        echo " Step 3: Creating service account file"
        echo "Writing service account to file..."
        echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > service-account.json
        echo "Service account file created, details:"
        echo "File exists: $(test -f service-account.json && echo 'YES' || echo 'NO')"
        echo "File size: $(wc -c < service-account.json) bytes"
        echo "File permissions: $(ls -la service-account.json)"
        
        echo " Step 4: Service account file content analysis"
        echo "Service account file hash verification:"
        SA_FILE_HASH=$(shasum -a 256 service-account.json | cut -d' ' -f1)
        echo "Service account file hash: ${SA_FILE_HASH:0:16}...${SA_FILE_HASH:48:16}"
        echo "File integrity verified without exposing content"
        
        echo " Step 5: JSON validation"
        if command -v jq >/dev/null 2>&1; then
            echo "jq is available"
            if jq empty service-account.json 2>/dev/null; then
                echo "[SUCCESS] JSON is valid"
                echo " Extracting fields with jq (secure verification):"
                PROJECT_ID=$(jq -r .project_id service-account.json 2>/dev/null)
                CLIENT_EMAIL=$(jq -r .client_email service-account.json 2>/dev/null)
                PRIVATE_KEY_ID=$(jq -r .private_key_id service-account.json 2>/dev/null)
                SERVICE_TYPE=$(jq -r .type service-account.json 2>/dev/null)
                AUTH_URI=$(jq -r .auth_uri service-account.json 2>/dev/null)
                
                echo "project_id length: ${#PROJECT_ID}"
                echo "client_email length: ${#CLIENT_EMAIL}"
                echo "private_key_id length: ${#PRIVATE_KEY_ID}"
                echo "type: '$SERVICE_TYPE'"
                echo "auth_uri domain: $(echo $AUTH_URI | cut -d'/' -f3)"
            else
                echo "[ERROR] JSON is INVALID"
                echo "jq error output:"
                jq empty service-account.json 2>&1 || true
            fi
        else
            echo "[ERROR] jq not available"
            echo "Trying python JSON validation:"
            python3 -c "import json; json.load(open('service-account.json'))" 2>&1 || echo "Python JSON validation failed"
        fi
        
        echo " Step 6: Firebase CLI availability"
        echo "Firebase CLI location: $(which firebase || echo 'NOT FOUND')"
        echo "Firebase CLI version:"
        firebase --version 2>&1 || echo "Firebase CLI not working"
        
        echo " Step 7: Node.js and npm info"
        echo "Node version: $(node --version 2>&1 || echo 'NOT FOUND')"
        echo "npm version: $(npm --version 2>&1 || echo 'NOT FOUND')"
        echo "Global npm packages:"
        npm list -g --depth=0 2>&1 || echo "Failed to list npm packages"
        
        echo " Step 8: Setting authentication"
        export GOOGLE_APPLICATION_CREDENTIALS="$(pwd)/service-account.json"
        echo "GOOGLE_APPLICATION_CREDENTIALS set to: '$GOOGLE_APPLICATION_CREDENTIALS'"
        echo "File exists at that path: $(test -f "$GOOGLE_APPLICATION_CREDENTIALS" && echo 'YES' || echo 'NO')"
        echo "Absolute path: $(realpath service-account.json 2>/dev/null || echo 'realpath failed')"
        
        echo " Step 9: Firebase authentication test (method 1 - environment variable)"
        echo "Testing firebase auth with environment variable..."
        firebase projects:list 2>&1 || echo "Method 1 failed"
        
        echo " Step 10: Firebase authentication test (method 2 - different approach)"
        echo "Testing firebase auth with explicit project..."
        firebase projects:list --project="$FIREBASE_PROJECT_ID" 2>&1 || echo "Method 2 failed"
        
        echo " Step 11: Firebase authentication test (method 3 - debug mode)"
        echo "Testing firebase auth with debug output..."
        firebase --debug projects:list 2>&1 | head -20 || echo "Method 3 failed"
        
        echo " Step 12: IPA file verification"
        echo "IPA_PATH variable: '$IPA_PATH'"
        echo "IPA file exists: $(test -f "$IPA_PATH" && echo 'YES' || echo 'NO')"
        if [ -f "$IPA_PATH" ]; then
            echo "IPA file details:"
            ls -lh "$IPA_PATH"
            echo "IPA file type:"
            file "$IPA_PATH" 2>&1 || echo "file command failed"
        else
            echo "[ERROR] IPA file not found, searching for alternatives..."
            echo "Looking for IPA files in build directory:"
            find . -name "*.ipa" -type f 2>/dev/null || echo "No IPA files found"
            echo "Contents of private-repo/runbuilder/build/:"
            ls -la private-repo/runbuilder/build/ 2>/dev/null || echo "Build directory not found"
        fi
        
        echo " Step 13: Firebase project access test"
        echo "Testing project access for: $FIREBASE_PROJECT_ID"
        firebase projects:list | grep "$FIREBASE_PROJECT_ID" 2>&1 || echo "Project not found in list"
        
        echo " Step 14: Firebase app distribution test (dry run)"
        echo "Testing appdistribution command availability..."
        firebase appdistribution --help 2>&1 || echo "App distribution command not available"
        
        echo " Step 15: Network connectivity test"
        echo "Testing network connectivity to Firebase..."
        curl -s -o /dev/null -w "HTTP Status: %{http_code}, Time: %{time_total}s" https://firebase.googleapis.com/ || echo "Network test failed"
        echo ""
        
        echo " =================================="
        echo " ATTEMPTING FIREBASE UPLOAD"
        echo " =================================="
        
        # Try multiple upload methods
        echo " Upload Method 1: Standard approach"
        firebase appdistribution:distribute "$IPA_PATH" \
          --app "$FIREBASE_APP_ID" \
          --project "$FIREBASE_PROJECT_ID" \
          --release-notes " RunBuilder iOS Build #${{ github.run_number }} - Debug Build" 2>&1 && {
          echo "[SUCCESS] Method 1 SUCCESS!"
          exit 0
        } || echo "[ERROR] Method 1 failed"
        
        echo " Upload Method 2: With debug flag"
        firebase appdistribution:distribute "$IPA_PATH" \
          --app "$FIREBASE_APP_ID" \
          --project "$FIREBASE_PROJECT_ID" \
          --debug \
          --release-notes " RunBuilder iOS Build #${{ github.run_number }} - Debug Build" 2>&1 && {
          echo "[SUCCESS] Method 2 SUCCESS!"
          exit 0
        } || echo "[ERROR] Method 2 failed"
        
        echo " Upload Method 3: Using Google Cloud auth action credentials"
        echo "Trying with Google Cloud auth action credentials..."
        firebase appdistribution:distribute "$IPA_PATH" \
          --app "$FIREBASE_APP_ID" \
          --project "$FIREBASE_PROJECT_ID" \
          --release-notes " RunBuilder iOS Build #${{ github.run_number }} - Debug Build" 2>&1 && {
          echo "[SUCCESS] Method 3 SUCCESS!"
          exit 0
        } || echo "[ERROR] Method 3 failed"
        
        echo " Upload Method 4: Using alternative authentication"
        echo "Trying alternative Firebase authentication approach..."
        GOOGLE_APPLICATION_CREDENTIALS="$(pwd)/service-account.json" firebase appdistribution:distribute "$IPA_PATH" \
          --app "$FIREBASE_APP_ID" \
          --project "$FIREBASE_PROJECT_ID" \
          --release-notes " RunBuilder iOS Build #${{ github.run_number }} - Debug Build" 2>&1 && {
          echo "[SUCCESS] Method 4 SUCCESS!"
          exit 0
        } || echo "[ERROR] Method 4 failed"
        
        echo " =================================="
        echo " ALL METHODS FAILED - FINAL DEBUG"
        echo " =================================="
        
        echo " Final environment dump (secure):"
        echo "Environment variables containing Firebase/Google (count only):"
        env | grep -E "(FIREBASE|GOOGLE|GCLOUD)" | wc -l
        echo "FIREBASE_PROJECT_ID present: $([ -n "$FIREBASE_PROJECT_ID" ] && echo 'YES' || echo 'NO')"
        echo "FIREBASE_APP_ID present: $([ -n "$FIREBASE_APP_ID" ] && echo 'YES' || echo 'NO')"
        echo "GOOGLE_APPLICATION_CREDENTIALS present: $([ -n "$GOOGLE_APPLICATION_CREDENTIALS" ] && echo 'YES' || echo 'NO')"
        
        echo " Final file system state:"
        echo "Current directory contents:"
        ls -la
        echo "Service account file final state:"
        ls -la service-account.json 2>/dev/null || echo "Service account file missing"
        
        echo " Firebase CLI final diagnostics:"
        firebase --version 2>&1 || echo "Firebase CLI not available"
        firebase projects:list 2>&1 | head -10 || echo "Cannot list projects"
        
        echo " =================================="
        echo " FAILURE - EXITING WITH ERROR"
        echo " =================================="
        exit 1
          
    - name: Create Release Notes
      run: |
        echo " iOS build completed successfully!" >> release_notes.txt
        echo " Build #${{ github.run_number }}" >> release_notes.txt
        echo " Download the IPA from GitHub Actions artifacts" >> release_notes.txt
        echo " Release Notes: ${{ github.event.inputs.release_notes || 'Auto-rebuild to prevent expiration' }}" >> release_notes.txt
        echo "" >> release_notes.txt
        echo " Installation Instructions:" >> release_notes.txt
        echo "1. Download the IPA file from the Actions artifacts" >> release_notes.txt
        echo "2. Install using Xcode, TestFlight, or a device management tool" >> release_notes.txt
        echo "3. Trust the developer profile in Settings > General > VPN & Device Management" >> release_notes.txt
        
    - name: Upload Release Notes
      uses: actions/upload-artifact@v4
      with:
        name: release-notes
        path: release_notes.txt
        
    - name: Clean up keychain and provisioning profile
      if: ${{ always() }}
      run: |
        security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
        rm -f ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision || true
